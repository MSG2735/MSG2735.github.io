<!DOCTYPE html>
<html>
<head>
    <title>Physics Wheels</title>
    <style>
        canvas {
            border: 2px solid #000;
            background: #f0f0f0;
        }
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            text-shadow: 2px 2px 2px black;
        }
    </style>
</head>
<body>
    <div id="ui">Health: <span id="health">100</span>% | Score: <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script>
        // Engine setup
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Composites = Matter.Composites,
            Constraint = Matter.Constraint,
            Events = Matter.Events,
            Mouse = Matter.Mouse,
            MouseConstraint = Matter.MouseConstraint;

        const canvas = document.getElementById('gameCanvas');
        const engine = Engine.create();
        const render = Render.create({
            element: document.body,
            engine: engine,
            canvas: canvas,
            options: {
                width: 1280,
                height: 720,
                wireframes: false,
                background: '#f0f0f0'
            }
        });

        // Game State
        let player = null;
        let projectiles = [];
        let health = 100;
        let score = 0;
        let isGameOver = false;

        // Initialize physics world
        function initWorld() {
            // Ground
            Composite.add(engine.world, [
                Bodies.rectangle(640, 710, 1280, 20, { 
                    isStatic: true,
                    render: { fillStyle: '#666666' }
                }),
                // Obstacles
                Bodies.rectangle(500, 600, 200, 20, {
                    isStatic: true,
                    angle: Math.PI * 0.1,
                    render: { fillStyle: '#ff0000' }
                }),
                Bodies.rectangle(900, 650, 100, 100, {
                    isStatic: true,
                    render: { fillStyle: '#00ff00' }
                }),
                // Spikes
                Bodies.trapezoid(300, 650, 50, 30, 0.8, {
                    isStatic: true,
                    render: { fillStyle: '#000000' }
                })
            ]);
        }

        // Player creation
        function createPlayer() {
            // Bicycle vehicle
            const vehicle = Composites.car(200, 500, 100, 50, 30);
            
            // Rider
            const rider = Composites.stack(240, 450, 1, 2, 0, 0, (x, y) => {
                return Bodies.circle(x, y, 15, {
                    render: {
                        fillStyle: '#ffffff',
                        lineWidth: 2,
                        strokeStyle: '#000000'
                    }
                });
            });
            
            // Connect rider to vehicle
            Composite.add(vehicle, [
                Constraint.create({
                    bodyA: vehicle.bodies[0],
                    bodyB: rider.bodies[0],
                    pointA: { x: 25, y: 0 },
                    pointB: { x: 0, y: -15 },
                    stiffness: 0.5
                })
            ]);

            Composite.add(engine.world, [vehicle, rider]);
            return { vehicle, rider };
        }

        // Projectile system
        function shootProjectile(position, angle) {
            const projectile = Bodies.circle(
                position.x,
                position.y,
                5,
                {
                    label: 'projectile',
                    density: 0.1,
                    render: { fillStyle: '#ffff00' }
                }
            );
            
            Matter.Body.setVelocity(projectile, {
                x: Math.cos(angle) * 15,
                y: Math.sin(angle) * 15
            });
            
            Composite.add(engine.world, projectile);
            projectiles.push(projectile);
        }

        // Damage system
        function applyDamage(body, amount) {
            if (body.label === 'rider') {
                health = Math.max(0, health - amount);
                document.getElementById('health').textContent = health;
                
                body.render.fillStyle = '#ff0000';
                setTimeout(() => {
                    if (body.render) body.render.fillStyle = '#ffffff';
                }, 200);
                
                if (health <= 0) gameOver();
            }
        }

        // Collision handling
        function handleCollisions() {
            Events.on(engine, 'collisionStart', event => {
                event.pairs.forEach(pair => {
                    const bodies = [pair.bodyA, pair.bodyB];
                    
                    // Projectile collisions
                    bodies.forEach(body => {
                        if (body.label === 'projectile') {
                            Composite.remove(engine.world, body);
                            projectiles = projectiles.filter(p => p !== body);
                        }
                    });

                    // Spike damage
                    if (bodies.some(b => b.label === 'rider') && 
                        bodies.some(b => b.render.fillStyle === '#000000')) {
                        applyDamage(bodies.find(b => b.label === 'rider'), 25);
                    }
                });
            });
        }

        // Game state management
        function gameOver() {
            isGameOver = true;
            alert(`Game Over! Score: ${score}`);
            resetGame();
        }

        function resetGame() {
            Composite.clear(engine.world);
            initWorld();
            player = createPlayer();
            health = 100;
            score = 0;
            isGameOver = false;
            document.getElementById('health').textContent = health;
            document.getElementById('score').textContent = score;
        }

        // Controls
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        function handleControls() {
            if (isGameOver) return;

            if (keys['ArrowLeft']) {
                Matter.Body.setAngularVelocity(player.vehicle.bodies[1], -0.05);
            }
            if (keys['ArrowRight']) {
                Matter.Body.setAngularVelocity(player.vehicle.bodies[1], 0.05);
            }
            if (keys['ArrowUp']) {
                Matter.Body.setVelocity(player.vehicle.bodies[0], {
                    x: player.vehicle.bodies[0].velocity.x,
                    y: -5
                });
            }
            if (keys[' ']) {
                const position = player.vehicle.bodies[0].position;
                shootProjectile(position, Math.PI);
                score += 10;
                document.getElementById('score').textContent = score;
            }
        }

        // Blood particle system
        function createBloodSplatter(position) {
            const splatter = Composites.stack(position.x - 10, position.y - 10, 5, 5, 0, 0, (x, y) => {
                return Bodies.circle(x, y, 2, {
                    render: { fillStyle: '#ff0000' },
                    friction: 0.1,
                    lifetime: 100
                });
            });
            
            Composite.add(engine.world, splatter);
        }

        // Game loop
        function update() {
            handleControls();
            
            // Update physics
            Engine.update(engine);
            
            // Cleanup old projectiles
            projectiles.forEach((projectile, index) => {
                if (projectile.position.y > 720 || 
                    projectile.position.x < 0 || 
                    projectile.position.x > 1280) {
                    Composite.remove(engine.world, projectile);
                    projectiles.splice(index, 1);
                }
            });
            
            requestAnimationFrame(update);
        }

        // Initialize game
        initWorld();
        player = createPlayer();
        handleCollisions();
        Runner.run(engine);
        Render.run(render);
        update();

        // Add mouse control
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: { visible: false }
            }
        });
        Composite.add(engine.world, mouseConstraint);
        render.mouse = mouse;
    </script>
</body>
</html>